#include "Set.h"

#include <corecrt_malloc.h>

/**
 * Конструктор с параметром создает множество по массиву элементов
 * @param els - элементы массива, добавляемые во множество
 */
Set::Set(int* els)
{
	//Проверяем, что массив не пустой
	if (!els) return;
	//Вычисляем размер массива как его размер в байтах поделенный на размер 0го элемента
	auto sz = _msize(els) / sizeof *els;
	//Добавляем каждый элемент по очереди во множество
	for (size_t i = 0; i<sz; i++)
	{
		add(els[i]);
	}
}

/**
 * Метод добавления элемента в множество
 * @param elem - добавляемый элемент
 * @return возвращает true, если элемент добавлен и false, если элемент уже был во множестве
 */
bool Set::add(int el)
{
	//Проверка на наличие добавляемых элементов во множестве
	if (!is_in_set(el))
	{
		//Если элемент отсутствовал во множестве, выделяем память для хранения в списке
		elem* newel = new elem;
		//заполняем значение
		newel->value = el;
		//Если множество было пустым, то новый элемент становится первым и последним
		if (!first_el) first_el = last_el = newel;
		else {
			//Если во множестве были элементы, то добавляем новый элемент после последнего
			last_el->next = newel;
			last_el = newel;
		}
		//Увеличиваем мощность множества
		cardinality++;
		return true;
	}
	return false;
}

/**
 * Метод удаления элемента из множества
 * @param el - удаляемый элемент
 * @return - возвращает true, если элемент был удален, в противном случае - false;
 */
bool Set::remove(int el)
{
	//Если списка нет (множество пустое), сразу выходим
	if (!first_el) return false;
	if (first_el->value == el)
	{
		//Если нужно удалить первый элемент
		elem* del = first_el;
		first_el = first_el->next;
		delete del;
		//Если первый элемент обнулился, то обнуляется и последний
		if (!first_el) last_el = nullptr;
		return true;
	}
	//Устанавливаем указатель на первый элемент
	elem* curr = first_el;
	//Пока не дойдем до предпоследнего элемента множества или элемента, значение которого
	//равно удаляемому значению
	while (curr->next && curr->next->value != el)
	{
		//переходим к следующему элементу
		curr = curr->next;
	}
	//Если есть следующий элемент, значит цикл остановился потому, что значение
	//следующего элемента было искомым
	if (curr->next)
	{
		//Удаляем элемент, следующий за текущим
		elem* del = curr->next;
		curr->next = curr->next->next;
		delete del;
		//Если новый следующий элемент для текущего стал пуст, значит
		//был удален последний элемент: обновляем соответствующий указатель.
		if (!curr->next) last_el = curr;
		return true;
	}
	return false;
}

/**
 * Метод проверки наличия элемента во множестве
 * @param el проверяемый на наличие во множестве элемент
 * @return возвращает true, если элемент присутствует во множестве и false, в противном случае
 */
bool Set::is_in_set(int el)
{
	//Устанавливаем указатель на первый элемент
	elem* curr = first_el;
	//Пока не выйдем за пределы списка элементов множества
	while (curr)
	{
		//Если найден элемент, возвращаем true
		if (curr->value == el) return true;
		//иначе переходим к следующему элементу
		curr = curr->next;
	}
	return false;
}
